import { api } from '../../../scripts/api.js';
import { app } from '../../../scripts/app.js';

// é¢„è®¾ç®¡ç†æœåŠ¡
class PresetService {
    // è·å–é¢„è®¾åˆ—è¡¨
    static async getPresets() {
        try {
            const response = await api.fetchApi("/axun/AIAssistant/presets", {
                method: "POST"
            });
            return await response.json();
        } catch (error) {
            console.error("[AIAssistant] è·å–é¢„è®¾åˆ—è¡¨å¤±è´¥:", error);
            return {};
        }
    }

    // ä¿å­˜é¢„è®¾
    static async savePreset(type, preset) {
        try {
            const response = await api.fetchApi("/axun/AIAssistant/save_preset", {
                method: "POST",
                body: JSON.stringify({ type, ...preset })
            });
            const result = await response.json();
            
            // å¤„ç†éœ€è¦ç¡®è®¤è¦†ç›–çš„æƒ…å†µ
            if (result.status === "confirm_required") {
                if (confirm(result.message)) {
                    // ç”¨æˆ·ç¡®è®¤è¦†ç›–ï¼Œé‡æ–°å‘é€è¯·æ±‚
                    const confirmResponse = await api.fetchApi("/axun/AIAssistant/save_preset", {
                        method: "POST",
                        body: JSON.stringify({ type, ...preset, confirm_overwrite: true })
                    });
                    const confirmResult = await confirmResponse.json();
                    return confirmResult.status === "success";
                }
                return false;
            }
            
            return result.status === "success";
        } catch (error) {
            console.error("[AIAssistant] ä¿å­˜é¢„è®¾å¤±è´¥:", error);
            return false;
        }
    }

    // åˆ é™¤é¢„è®¾
    static async deletePreset(type, presetName) {
        try {
            const response = await api.fetchApi("/axun/AIAssistant/delete_preset", {
                method: "POST",
                body: JSON.stringify({ type, name: presetName })
            });
            const result = await response.json();
            return result.status === "success";
        } catch (error) {
            console.error("[AIAssistant] åˆ é™¤é¢„è®¾å¤±è´¥:", error);
            return false;
        }
    }
}

// åˆ›å»ºé¢„è®¾å¯¹è¯æ¡†
function createPresetDialog(type, title, fields, presets) {
    const dialog = document.createElement("dialog");
    dialog.style.padding = "20px";
    dialog.style.borderRadius = "8px";
    dialog.style.backgroundColor = "#2d2d2d";
    dialog.style.color = "#ffffff";
    dialog.style.border = "1px solid #666";
    dialog.style.minWidth = "400px";
    
    // æ·»åŠ é¢„è®¾é€‰æ‹©ä¸‹æ‹‰æ¡†
    const presetOptions = Object.keys(presets).map(name => 
        `<option value="${name}">${name}</option>`
    ).join('');
    
    let fieldsHtml = `
        <div>
            <label>é€‰æ‹©å·²æœ‰é¢„è®¾:</label>
            <select id="preset_select" style="width: 100%; padding: 5px; background: #333; border: 1px solid #666; color: #fff; border-radius: 4px;">
                <option value="">-- æ–°å»ºé¢„è®¾ --</option>
                ${presetOptions}
            </select>
        </div>`;
    
    for (const [key, config] of Object.entries(fields)) {
        const { label, type: inputType, rows } = config;
        if (inputType === "textarea") {
            fieldsHtml += `
                <div>
                    <label>${label}:</label>
                    <textarea id="${key}" rows="${rows || 5}" 
                        style="width: 100%; padding: 5px; background: #333; border: 1px solid #666; color: #fff; border-radius: 4px; resize: vertical;"></textarea>
                </div>`;
        } else {
            fieldsHtml += `
                <div>
                    <label>${label}:</label>
                    <input type="${inputType}" id="${key}" ${inputType === "number" ? 'step="0.1" min="0" max="2"' : ''} 
                        style="width: 100%; padding: 5px; background: #333; border: 1px solid #666; color: #fff; border-radius: 4px;">
                </div>`;
        }
    }
    
    dialog.innerHTML = `
        <h3 style="margin-top: 0;">${title}</h3>
        <form method="dialog" style="display: flex; flex-direction: column; gap: 15px;">
            ${fieldsHtml}
            <div style="text-align: right; margin-top: 10px;">
                <button type="button" onclick="this.closest('dialog').close()" 
                    style="padding: 5px 15px; margin-right: 10px; background: #444; border: 1px solid #666; color: #fff; border-radius: 4px; cursor: pointer;">
                    å–æ¶ˆ
                </button>
                <button type="button" id="load_preset_btn"
                    style="padding: 5px 15px; margin-right: 10px; background: #444; border: 1px solid #666; color: #fff; border-radius: 4px; cursor: pointer;">
                    è½½å…¥
                </button>
                <button type="submit" 
                    style="padding: 5px 15px; background: #1e90ff; border: none; color: #fff; border-radius: 4px; cursor: pointer;">
                    ä¿å­˜
                </button>
            </div>
        </form>
    `;
    
    // æ·»åŠ è½½å…¥é¢„è®¾åŠŸèƒ½
    const loadPresetBtn = dialog.querySelector("#load_preset_btn");
    const presetSelect = dialog.querySelector("#preset_select");
    
    loadPresetBtn.onclick = () => {
        const selectedPreset = presetSelect.value;
        if (!selectedPreset) {
            alert("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªé¢„è®¾");
            return;
        }
        
        const preset = presets[selectedPreset];
        if (!preset) return;
        
        // è®¾ç½®é¢„è®¾åç§°
        const nameInput = dialog.querySelector("#name");
        if (nameInput) nameInput.value = selectedPreset;
        
        // æ ¹æ®é¢„è®¾ç±»å‹è®¾ç½®å…¶ä»–å­—æ®µ
        if (type === "system") {
            const systemPromptInput = dialog.querySelector("#system_prompt");
            const temperatureInput = dialog.querySelector("#temperature");
            const topPInput = dialog.querySelector("#top_p");
            
            if (systemPromptInput) systemPromptInput.value = preset.system_prompt || "";
            if (temperatureInput) temperatureInput.value = preset.temperature || 0.7;
            if (topPInput) topPInput.value = preset.top_p || 0.9;
        } else {
            const promptInput = dialog.querySelector("#prompt");
            if (promptInput) promptInput.value = preset.prompt || "";
        }
    };
    
    return dialog;
}

// æ³¨å†Œé¢„è®¾èŠ‚ç‚¹
app.registerExtension({
    name: "axun.AIAssistant.preset",
    async beforeRegisterNodeDef(nodeType, nodeData, app) {
        if (nodeData.name === "AIAssistantPreset") {
            const originalNodeCreated = nodeType.prototype.onNodeCreated;
            
            nodeType.prototype.onNodeCreated = async function() {
                if (originalNodeCreated) {
                    originalNodeCreated.apply(this, arguments);
                }

                const node = this;
                
                // è·å–æ‰€æœ‰é¢„è®¾é€‰æ‹©æ§ä»¶
                const presetWidgets = {
                    system: node.widgets.find(w => w.name === "system_preset"),
                    style: node.widgets.find(w => w.name === "style_preset"),
                    shot: node.widgets.find(w => w.name === "shot_preset"),
                    character_a: node.widgets.find(w => w.name === "character_a_preset"),
                    character_b: node.widgets.find(w => w.name === "character_b_preset"),
                    character_c: node.widgets.find(w => w.name === "character_c_preset")
                };

                // è·å–è‡ªå®šä¹‰æç¤ºè¯è¾“å…¥æ¡†
                const customPromptWidget = node.widgets.find(w => w.name === "custom_prompt");

                // æ›´æ–°é¢„è®¾åˆ—è¡¨
                const updatePresets = async () => {
                    try {
                        const presets = await PresetService.getPresets();
                        console.log("[AIAssistant] åŠ è½½åˆ°çš„é¢„è®¾:", presets);
                        
                        // æ›´æ–°ç³»ç»Ÿé¢„è®¾
                        if (presetWidgets.system) {
                            presetWidgets.system.options.values = Object.keys(presets.system_presets || {});
                            presetWidgets.system.value = presetWidgets.system.options.values[0] || "null";
                        }
                        
                        // æ›´æ–°é£æ ¼é¢„è®¾
                        if (presetWidgets.style) {
                            presetWidgets.style.options.values = Object.keys(presets.style_presets || {});
                            presetWidgets.style.value = presetWidgets.style.options.values[0] || "null";
                        }
                        
                        // æ›´æ–°é•œå¤´é¢„è®¾
                        if (presetWidgets.shot) {
                            presetWidgets.shot.options.values = Object.keys(presets.shot_presets || {});
                            presetWidgets.shot.value = presetWidgets.shot.options.values[0] || "null";
                        }
                        
                        // æ›´æ–°è§’è‰²é¢„è®¾
                        const characterOptions = Object.keys(presets.character_presets || {});
                        console.log("[AIAssistant] è§’è‰²é¢„è®¾é€‰é¡¹:", characterOptions);
                        
                        for (const widget of [presetWidgets.character_a, presetWidgets.character_b, presetWidgets.character_c]) {
                            if (widget) {
                                widget.options = widget.options || {};
                                widget.options.values = characterOptions;
                                widget.value = characterOptions[0] || "null";
                                widget.type = "combo";
                                widget.options.editable = false;
                            }
                        }
                        
                        // æ›´æ–°è‡ªå®šä¹‰æç¤ºè¯è¾“å…¥æ¡†
                        if (customPromptWidget) {
                            customPromptWidget.type = "textarea";
                            customPromptWidget.options = customPromptWidget.options || {};
                            customPromptWidget.options.multiline = true;
                        }
                        
                        app.graph.setDirtyCanvas(true);
                    } catch (error) {
                        console.error("[AIAssistant] æ›´æ–°é¢„è®¾å¤±è´¥:", error);
                    }
                };

                // ä¸ºæ¯ç§é¢„è®¾ç±»å‹æ·»åŠ ç¼–è¾‘æŒ‰é’®
                const presetConfigs = {
                    system: {
                        title: "ç¼–è¾‘åœºæ™¯é¢„è®¾",
                        fields: {
                            name: { label: "é¢„è®¾åç§°", type: "text" },
                            system_prompt: { label: "ç³»ç»Ÿæç¤ºè¯", type: "textarea", rows: 5 },
                            temperature: { label: "Temperature", type: "number" },
                            top_p: { label: "Top P", type: "number" }
                        }
                    },
                    style: {
                        title: "ç¼–è¾‘é£æ ¼é¢„è®¾",
                        fields: {
                            name: { label: "é£æ ¼åç§°", type: "text" },
                            prompt: { label: "é£æ ¼æç¤ºè¯", type: "textarea", rows: 5 }
                        }
                    },
                    shot: {
                        title: "ç¼–è¾‘é•œå¤´é¢„è®¾",
                        fields: {
                            name: { label: "é•œå¤´åç§°", type: "text" },
                            prompt: { label: "é•œå¤´æç¤ºè¯", type: "textarea", rows: 5 }
                        }
                    },
                    character_a: {
                        title: "ç¼–è¾‘è§’è‰²Aé¢„è®¾",
                        fields: {
                            name: { label: "è§’è‰²åç§°", type: "text" },
                            prompt: { label: "è§’è‰²æç¤ºè¯", type: "textarea", rows: 5 }
                        }
                    },
                    character_b: {
                        title: "ç¼–è¾‘è§’è‰²Bé¢„è®¾",
                        fields: {
                            name: { label: "è§’è‰²åç§°", type: "text" },
                            prompt: { label: "è§’è‰²æç¤ºè¯", type: "textarea", rows: 5 }
                        }
                    },
                    character_c: {
                        title: "ç¼–è¾‘è§’è‰²Cé¢„è®¾",
                        fields: {
                            name: { label: "è§’è‰²åç§°", type: "text" },
                            prompt: { label: "è§’è‰²æç¤ºè¯", type: "textarea", rows: 5 }
                        }
                    }
                };

                // é‡æ–°æ’åˆ—widgetsé¡ºåº
                const newWidgets = [];
                
                for (const [type, config] of Object.entries(presetConfigs)) {
                    const widget = presetWidgets[type];
                    if (!widget) continue;

                    // æ·»åŠ é€‰æ‹©æ§ä»¶
                    widget.type = "combo";
                    widget.options = widget.options || {};
                    widget.options.values = widget.options.values || [];
                    widget.options.editable = true;
                    newWidgets.push(widget);

                    // æ·»åŠ ç¼–è¾‘æŒ‰é’®
                    const editButton = node.addWidget("button", config.title, null, async () => {
                        const presets = await PresetService.getPresets();
                        const presetKey = type.startsWith("character") ? "character_presets" : `${type}_presets`;
                        const dialog = createPresetDialog(type, config.title, config.fields, presets[presetKey] || {});
                        
                        dialog.querySelector("form").onsubmit = async (e) => {
                            e.preventDefault();
                            
                            const formData = {};
                            for (const [key, field] of Object.entries(config.fields)) {
                                const input = dialog.querySelector(`#${key}`);
                                if (field.type === "number") {
                                    formData[key] = parseFloat(input.value);
                                } else {
                                    formData[key] = input.value;
                                }
                            }
                            
                            const { name, ...preset } = formData;
                            if (!name) {
                                alert("è¯·è¾“å…¥é¢„è®¾åç§°");
                                return;
                            }

                            // å¯¹äºè§’è‰²é¢„è®¾ï¼Œä½¿ç”¨ character ä½œä¸ºç±»å‹
                            const saveType = type.startsWith("character") ? "character" : type;
                            const success = await PresetService.savePreset(saveType, { name, ...preset });
                            if (success) {
                                await updatePresets();
                                widget.value = name;
                                dialog.close();
                            } else {
                                alert("ä¿å­˜é¢„è®¾å¤±è´¥");
                            }
                        };

                        document.body.appendChild(dialog);
                        dialog.showModal();
                    });
                    newWidgets.push(editButton);
                }

                // æ·»åŠ è‡ªå®šä¹‰æç¤ºè¯è¾“å…¥æ¡†
                if (customPromptWidget) {
                    customPromptWidget.type = "textarea";
                    customPromptWidget.options = customPromptWidget.options || {};
                    customPromptWidget.options.multiline = true;
                    newWidgets.push(customPromptWidget);
                }

                // æ·»åŠ éšæœºç§å­æ§ä»¶
                const seedWidget = node.widgets.find(w => w.name === "seed");
                if (seedWidget) {
                    // åˆ›å»ºç§å­æ•°å€¼æ˜¾ç¤ºæ§ä»¶
                    seedWidget.type = "number";
                    seedWidget.options = seedWidget.options || {};
                    seedWidget.options.min = 0;
                    seedWidget.options.max = Number.MAX_SAFE_INTEGER;
                    seedWidget.options.step = 1;
                    seedWidget.options.precision = 0;
                    newWidgets.push(seedWidget);

                    // åˆ›å»ºéšæœºç§å­æŒ‰é’®
                    const randomSeedButton = node.addWidget("button", "ğŸ²", null, () => {
                        seedWidget.value = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
                        app.graph.setDirtyCanvas(true);
                    });
                    randomSeedButton.serialize = false;
                    newWidgets.push(randomSeedButton);
                }

                // æ›´æ–°èŠ‚ç‚¹çš„widgets
                node.widgets = newWidgets;

                // åˆå§‹åŠ è½½é¢„è®¾åˆ—è¡¨
                await updatePresets();
            };
        }
    }
}); 